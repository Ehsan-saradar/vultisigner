// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"vultisigner/ent/ecdsalocaldata"
	"vultisigner/ent/ecdsapub"
	"vultisigner/ent/eddsalocaldata"
	"vultisigner/ent/pailliersk"
	"vultisigner/ent/predicate"
	"vultisigner/ent/schema"
	"vultisigner/ent/vault"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeECDSAPub       = "ECDSAPub"
	TypeEcdsaLocalData = "EcdsaLocalData"
	TypeEddsaLocalData = "EddsaLocalData"
	TypePaillierSK     = "PaillierSK"
	TypeVault          = "Vault"
)

// ECDSAPubMutation represents an operation that mutates the ECDSAPub nodes in the graph.
type ECDSAPubMutation struct {
	config
	op            Op
	typ           string
	id            *int
	curve         *string
	coords        *[]string
	appendcoords  []string
	clearedFields map[string]struct{}
	vault         *int
	clearedvault  bool
	done          bool
	oldValue      func(context.Context) (*ECDSAPub, error)
	predicates    []predicate.ECDSAPub
}

var _ ent.Mutation = (*ECDSAPubMutation)(nil)

// ecdsapubOption allows management of the mutation configuration using functional options.
type ecdsapubOption func(*ECDSAPubMutation)

// newECDSAPubMutation creates new mutation for the ECDSAPub entity.
func newECDSAPubMutation(c config, op Op, opts ...ecdsapubOption) *ECDSAPubMutation {
	m := &ECDSAPubMutation{
		config:        c,
		op:            op,
		typ:           TypeECDSAPub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withECDSAPubID sets the ID field of the mutation.
func withECDSAPubID(id int) ecdsapubOption {
	return func(m *ECDSAPubMutation) {
		var (
			err   error
			once  sync.Once
			value *ECDSAPub
		)
		m.oldValue = func(ctx context.Context) (*ECDSAPub, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ECDSAPub.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withECDSAPub sets the old ECDSAPub of the mutation.
func withECDSAPub(node *ECDSAPub) ecdsapubOption {
	return func(m *ECDSAPubMutation) {
		m.oldValue = func(context.Context) (*ECDSAPub, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ECDSAPubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ECDSAPubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ECDSAPubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ECDSAPubMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ECDSAPub.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurve sets the "curve" field.
func (m *ECDSAPubMutation) SetCurve(s string) {
	m.curve = &s
}

// Curve returns the value of the "curve" field in the mutation.
func (m *ECDSAPubMutation) Curve() (r string, exists bool) {
	v := m.curve
	if v == nil {
		return
	}
	return *v, true
}

// OldCurve returns the old "curve" field's value of the ECDSAPub entity.
// If the ECDSAPub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ECDSAPubMutation) OldCurve(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurve is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurve requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurve: %w", err)
	}
	return oldValue.Curve, nil
}

// ResetCurve resets all changes to the "curve" field.
func (m *ECDSAPubMutation) ResetCurve() {
	m.curve = nil
}

// SetCoords sets the "coords" field.
func (m *ECDSAPubMutation) SetCoords(s []string) {
	m.coords = &s
	m.appendcoords = nil
}

// Coords returns the value of the "coords" field in the mutation.
func (m *ECDSAPubMutation) Coords() (r []string, exists bool) {
	v := m.coords
	if v == nil {
		return
	}
	return *v, true
}

// OldCoords returns the old "coords" field's value of the ECDSAPub entity.
// If the ECDSAPub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ECDSAPubMutation) OldCoords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoords: %w", err)
	}
	return oldValue.Coords, nil
}

// AppendCoords adds s to the "coords" field.
func (m *ECDSAPubMutation) AppendCoords(s []string) {
	m.appendcoords = append(m.appendcoords, s...)
}

// AppendedCoords returns the list of values that were appended to the "coords" field in this mutation.
func (m *ECDSAPubMutation) AppendedCoords() ([]string, bool) {
	if len(m.appendcoords) == 0 {
		return nil, false
	}
	return m.appendcoords, true
}

// ResetCoords resets all changes to the "coords" field.
func (m *ECDSAPubMutation) ResetCoords() {
	m.coords = nil
	m.appendcoords = nil
}

// SetVaultID sets the "vault" edge to the Vault entity by id.
func (m *ECDSAPubMutation) SetVaultID(id int) {
	m.vault = &id
}

// ClearVault clears the "vault" edge to the Vault entity.
func (m *ECDSAPubMutation) ClearVault() {
	m.clearedvault = true
}

// VaultCleared reports if the "vault" edge to the Vault entity was cleared.
func (m *ECDSAPubMutation) VaultCleared() bool {
	return m.clearedvault
}

// VaultID returns the "vault" edge ID in the mutation.
func (m *ECDSAPubMutation) VaultID() (id int, exists bool) {
	if m.vault != nil {
		return *m.vault, true
	}
	return
}

// VaultIDs returns the "vault" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VaultID instead. It exists only for internal usage by the builders.
func (m *ECDSAPubMutation) VaultIDs() (ids []int) {
	if id := m.vault; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVault resets all changes to the "vault" edge.
func (m *ECDSAPubMutation) ResetVault() {
	m.vault = nil
	m.clearedvault = false
}

// Where appends a list predicates to the ECDSAPubMutation builder.
func (m *ECDSAPubMutation) Where(ps ...predicate.ECDSAPub) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ECDSAPubMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ECDSAPubMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ECDSAPub, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ECDSAPubMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ECDSAPubMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ECDSAPub).
func (m *ECDSAPubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ECDSAPubMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.curve != nil {
		fields = append(fields, ecdsapub.FieldCurve)
	}
	if m.coords != nil {
		fields = append(fields, ecdsapub.FieldCoords)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ECDSAPubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ecdsapub.FieldCurve:
		return m.Curve()
	case ecdsapub.FieldCoords:
		return m.Coords()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ECDSAPubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ecdsapub.FieldCurve:
		return m.OldCurve(ctx)
	case ecdsapub.FieldCoords:
		return m.OldCoords(ctx)
	}
	return nil, fmt.Errorf("unknown ECDSAPub field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ECDSAPubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ecdsapub.FieldCurve:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurve(v)
		return nil
	case ecdsapub.FieldCoords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoords(v)
		return nil
	}
	return fmt.Errorf("unknown ECDSAPub field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ECDSAPubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ECDSAPubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ECDSAPubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ECDSAPub numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ECDSAPubMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ECDSAPubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ECDSAPubMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ECDSAPub nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ECDSAPubMutation) ResetField(name string) error {
	switch name {
	case ecdsapub.FieldCurve:
		m.ResetCurve()
		return nil
	case ecdsapub.FieldCoords:
		m.ResetCoords()
		return nil
	}
	return fmt.Errorf("unknown ECDSAPub field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ECDSAPubMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vault != nil {
		edges = append(edges, ecdsapub.EdgeVault)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ECDSAPubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ecdsapub.EdgeVault:
		if id := m.vault; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ECDSAPubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ECDSAPubMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ECDSAPubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvault {
		edges = append(edges, ecdsapub.EdgeVault)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ECDSAPubMutation) EdgeCleared(name string) bool {
	switch name {
	case ecdsapub.EdgeVault:
		return m.clearedvault
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ECDSAPubMutation) ClearEdge(name string) error {
	switch name {
	case ecdsapub.EdgeVault:
		m.ClearVault()
		return nil
	}
	return fmt.Errorf("unknown ECDSAPub unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ECDSAPubMutation) ResetEdge(name string) error {
	switch name {
	case ecdsapub.EdgeVault:
		m.ResetVault()
		return nil
	}
	return fmt.Errorf("unknown ECDSAPub edge %s", name)
}

// EcdsaLocalDataMutation represents an operation that mutates the EcdsaLocalData nodes in the graph.
type EcdsaLocalDataMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	n_tilde_i          *string
	h1i                *string
	h2i                *string
	alpha              *string
	beta               *string
	p                  *string
	q                  *string
	xi                 *string
	share_id           *string
	ks                 *[]string
	appendks           []string
	n_tilde_j          *[]string
	appendn_tilde_j    []string
	h1j                *[]string
	appendh1j          []string
	h2j                *[]string
	appendh2j          []string
	big_xj             *[]schema.ECDSAPub
	appendbig_xj       []schema.ECDSAPub
	paillier_pks       *[]string
	appendpaillier_pks []string
	clearedFields      map[string]struct{}
	vault              *int
	clearedvault       bool
	done               bool
	oldValue           func(context.Context) (*EcdsaLocalData, error)
	predicates         []predicate.EcdsaLocalData
}

var _ ent.Mutation = (*EcdsaLocalDataMutation)(nil)

// ecdsalocaldataOption allows management of the mutation configuration using functional options.
type ecdsalocaldataOption func(*EcdsaLocalDataMutation)

// newEcdsaLocalDataMutation creates new mutation for the EcdsaLocalData entity.
func newEcdsaLocalDataMutation(c config, op Op, opts ...ecdsalocaldataOption) *EcdsaLocalDataMutation {
	m := &EcdsaLocalDataMutation{
		config:        c,
		op:            op,
		typ:           TypeEcdsaLocalData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEcdsaLocalDataID sets the ID field of the mutation.
func withEcdsaLocalDataID(id int) ecdsalocaldataOption {
	return func(m *EcdsaLocalDataMutation) {
		var (
			err   error
			once  sync.Once
			value *EcdsaLocalData
		)
		m.oldValue = func(ctx context.Context) (*EcdsaLocalData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EcdsaLocalData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEcdsaLocalData sets the old EcdsaLocalData of the mutation.
func withEcdsaLocalData(node *EcdsaLocalData) ecdsalocaldataOption {
	return func(m *EcdsaLocalDataMutation) {
		m.oldValue = func(context.Context) (*EcdsaLocalData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EcdsaLocalDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EcdsaLocalDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EcdsaLocalDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EcdsaLocalDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EcdsaLocalData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNTildeI sets the "n_tilde_i" field.
func (m *EcdsaLocalDataMutation) SetNTildeI(s string) {
	m.n_tilde_i = &s
}

// NTildeI returns the value of the "n_tilde_i" field in the mutation.
func (m *EcdsaLocalDataMutation) NTildeI() (r string, exists bool) {
	v := m.n_tilde_i
	if v == nil {
		return
	}
	return *v, true
}

// OldNTildeI returns the old "n_tilde_i" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldNTildeI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNTildeI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNTildeI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNTildeI: %w", err)
	}
	return oldValue.NTildeI, nil
}

// ResetNTildeI resets all changes to the "n_tilde_i" field.
func (m *EcdsaLocalDataMutation) ResetNTildeI() {
	m.n_tilde_i = nil
}

// SetH1i sets the "h1i" field.
func (m *EcdsaLocalDataMutation) SetH1i(s string) {
	m.h1i = &s
}

// H1i returns the value of the "h1i" field in the mutation.
func (m *EcdsaLocalDataMutation) H1i() (r string, exists bool) {
	v := m.h1i
	if v == nil {
		return
	}
	return *v, true
}

// OldH1i returns the old "h1i" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldH1i(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH1i is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH1i requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH1i: %w", err)
	}
	return oldValue.H1i, nil
}

// ResetH1i resets all changes to the "h1i" field.
func (m *EcdsaLocalDataMutation) ResetH1i() {
	m.h1i = nil
}

// SetH2i sets the "h2i" field.
func (m *EcdsaLocalDataMutation) SetH2i(s string) {
	m.h2i = &s
}

// H2i returns the value of the "h2i" field in the mutation.
func (m *EcdsaLocalDataMutation) H2i() (r string, exists bool) {
	v := m.h2i
	if v == nil {
		return
	}
	return *v, true
}

// OldH2i returns the old "h2i" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldH2i(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH2i is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH2i requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH2i: %w", err)
	}
	return oldValue.H2i, nil
}

// ResetH2i resets all changes to the "h2i" field.
func (m *EcdsaLocalDataMutation) ResetH2i() {
	m.h2i = nil
}

// SetAlpha sets the "alpha" field.
func (m *EcdsaLocalDataMutation) SetAlpha(s string) {
	m.alpha = &s
}

// Alpha returns the value of the "alpha" field in the mutation.
func (m *EcdsaLocalDataMutation) Alpha() (r string, exists bool) {
	v := m.alpha
	if v == nil {
		return
	}
	return *v, true
}

// OldAlpha returns the old "alpha" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldAlpha(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlpha is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlpha requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlpha: %w", err)
	}
	return oldValue.Alpha, nil
}

// ResetAlpha resets all changes to the "alpha" field.
func (m *EcdsaLocalDataMutation) ResetAlpha() {
	m.alpha = nil
}

// SetBeta sets the "beta" field.
func (m *EcdsaLocalDataMutation) SetBeta(s string) {
	m.beta = &s
}

// Beta returns the value of the "beta" field in the mutation.
func (m *EcdsaLocalDataMutation) Beta() (r string, exists bool) {
	v := m.beta
	if v == nil {
		return
	}
	return *v, true
}

// OldBeta returns the old "beta" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldBeta(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeta: %w", err)
	}
	return oldValue.Beta, nil
}

// ResetBeta resets all changes to the "beta" field.
func (m *EcdsaLocalDataMutation) ResetBeta() {
	m.beta = nil
}

// SetP sets the "p" field.
func (m *EcdsaLocalDataMutation) SetP(s string) {
	m.p = &s
}

// P returns the value of the "p" field in the mutation.
func (m *EcdsaLocalDataMutation) P() (r string, exists bool) {
	v := m.p
	if v == nil {
		return
	}
	return *v, true
}

// OldP returns the old "p" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldP: %w", err)
	}
	return oldValue.P, nil
}

// ResetP resets all changes to the "p" field.
func (m *EcdsaLocalDataMutation) ResetP() {
	m.p = nil
}

// SetQ sets the "q" field.
func (m *EcdsaLocalDataMutation) SetQ(s string) {
	m.q = &s
}

// Q returns the value of the "q" field in the mutation.
func (m *EcdsaLocalDataMutation) Q() (r string, exists bool) {
	v := m.q
	if v == nil {
		return
	}
	return *v, true
}

// OldQ returns the old "q" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldQ(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQ is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQ requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQ: %w", err)
	}
	return oldValue.Q, nil
}

// ResetQ resets all changes to the "q" field.
func (m *EcdsaLocalDataMutation) ResetQ() {
	m.q = nil
}

// SetXi sets the "xi" field.
func (m *EcdsaLocalDataMutation) SetXi(s string) {
	m.xi = &s
}

// Xi returns the value of the "xi" field in the mutation.
func (m *EcdsaLocalDataMutation) Xi() (r string, exists bool) {
	v := m.xi
	if v == nil {
		return
	}
	return *v, true
}

// OldXi returns the old "xi" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldXi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXi: %w", err)
	}
	return oldValue.Xi, nil
}

// ResetXi resets all changes to the "xi" field.
func (m *EcdsaLocalDataMutation) ResetXi() {
	m.xi = nil
}

// SetShareID sets the "share_id" field.
func (m *EcdsaLocalDataMutation) SetShareID(s string) {
	m.share_id = &s
}

// ShareID returns the value of the "share_id" field in the mutation.
func (m *EcdsaLocalDataMutation) ShareID() (r string, exists bool) {
	v := m.share_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShareID returns the old "share_id" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldShareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareID: %w", err)
	}
	return oldValue.ShareID, nil
}

// ResetShareID resets all changes to the "share_id" field.
func (m *EcdsaLocalDataMutation) ResetShareID() {
	m.share_id = nil
}

// SetKs sets the "ks" field.
func (m *EcdsaLocalDataMutation) SetKs(s []string) {
	m.ks = &s
	m.appendks = nil
}

// Ks returns the value of the "ks" field in the mutation.
func (m *EcdsaLocalDataMutation) Ks() (r []string, exists bool) {
	v := m.ks
	if v == nil {
		return
	}
	return *v, true
}

// OldKs returns the old "ks" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldKs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKs: %w", err)
	}
	return oldValue.Ks, nil
}

// AppendKs adds s to the "ks" field.
func (m *EcdsaLocalDataMutation) AppendKs(s []string) {
	m.appendks = append(m.appendks, s...)
}

// AppendedKs returns the list of values that were appended to the "ks" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedKs() ([]string, bool) {
	if len(m.appendks) == 0 {
		return nil, false
	}
	return m.appendks, true
}

// ResetKs resets all changes to the "ks" field.
func (m *EcdsaLocalDataMutation) ResetKs() {
	m.ks = nil
	m.appendks = nil
}

// SetNTildeJ sets the "n_tilde_j" field.
func (m *EcdsaLocalDataMutation) SetNTildeJ(s []string) {
	m.n_tilde_j = &s
	m.appendn_tilde_j = nil
}

// NTildeJ returns the value of the "n_tilde_j" field in the mutation.
func (m *EcdsaLocalDataMutation) NTildeJ() (r []string, exists bool) {
	v := m.n_tilde_j
	if v == nil {
		return
	}
	return *v, true
}

// OldNTildeJ returns the old "n_tilde_j" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldNTildeJ(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNTildeJ is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNTildeJ requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNTildeJ: %w", err)
	}
	return oldValue.NTildeJ, nil
}

// AppendNTildeJ adds s to the "n_tilde_j" field.
func (m *EcdsaLocalDataMutation) AppendNTildeJ(s []string) {
	m.appendn_tilde_j = append(m.appendn_tilde_j, s...)
}

// AppendedNTildeJ returns the list of values that were appended to the "n_tilde_j" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedNTildeJ() ([]string, bool) {
	if len(m.appendn_tilde_j) == 0 {
		return nil, false
	}
	return m.appendn_tilde_j, true
}

// ResetNTildeJ resets all changes to the "n_tilde_j" field.
func (m *EcdsaLocalDataMutation) ResetNTildeJ() {
	m.n_tilde_j = nil
	m.appendn_tilde_j = nil
}

// SetH1j sets the "h1j" field.
func (m *EcdsaLocalDataMutation) SetH1j(s []string) {
	m.h1j = &s
	m.appendh1j = nil
}

// H1j returns the value of the "h1j" field in the mutation.
func (m *EcdsaLocalDataMutation) H1j() (r []string, exists bool) {
	v := m.h1j
	if v == nil {
		return
	}
	return *v, true
}

// OldH1j returns the old "h1j" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldH1j(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH1j is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH1j requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH1j: %w", err)
	}
	return oldValue.H1j, nil
}

// AppendH1j adds s to the "h1j" field.
func (m *EcdsaLocalDataMutation) AppendH1j(s []string) {
	m.appendh1j = append(m.appendh1j, s...)
}

// AppendedH1j returns the list of values that were appended to the "h1j" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedH1j() ([]string, bool) {
	if len(m.appendh1j) == 0 {
		return nil, false
	}
	return m.appendh1j, true
}

// ResetH1j resets all changes to the "h1j" field.
func (m *EcdsaLocalDataMutation) ResetH1j() {
	m.h1j = nil
	m.appendh1j = nil
}

// SetH2j sets the "h2j" field.
func (m *EcdsaLocalDataMutation) SetH2j(s []string) {
	m.h2j = &s
	m.appendh2j = nil
}

// H2j returns the value of the "h2j" field in the mutation.
func (m *EcdsaLocalDataMutation) H2j() (r []string, exists bool) {
	v := m.h2j
	if v == nil {
		return
	}
	return *v, true
}

// OldH2j returns the old "h2j" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldH2j(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH2j is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH2j requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH2j: %w", err)
	}
	return oldValue.H2j, nil
}

// AppendH2j adds s to the "h2j" field.
func (m *EcdsaLocalDataMutation) AppendH2j(s []string) {
	m.appendh2j = append(m.appendh2j, s...)
}

// AppendedH2j returns the list of values that were appended to the "h2j" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedH2j() ([]string, bool) {
	if len(m.appendh2j) == 0 {
		return nil, false
	}
	return m.appendh2j, true
}

// ResetH2j resets all changes to the "h2j" field.
func (m *EcdsaLocalDataMutation) ResetH2j() {
	m.h2j = nil
	m.appendh2j = nil
}

// SetBigXj sets the "big_xj" field.
func (m *EcdsaLocalDataMutation) SetBigXj(sp []schema.ECDSAPub) {
	m.big_xj = &sp
	m.appendbig_xj = nil
}

// BigXj returns the value of the "big_xj" field in the mutation.
func (m *EcdsaLocalDataMutation) BigXj() (r []schema.ECDSAPub, exists bool) {
	v := m.big_xj
	if v == nil {
		return
	}
	return *v, true
}

// OldBigXj returns the old "big_xj" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldBigXj(ctx context.Context) (v []schema.ECDSAPub, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigXj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigXj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigXj: %w", err)
	}
	return oldValue.BigXj, nil
}

// AppendBigXj adds sp to the "big_xj" field.
func (m *EcdsaLocalDataMutation) AppendBigXj(sp []schema.ECDSAPub) {
	m.appendbig_xj = append(m.appendbig_xj, sp...)
}

// AppendedBigXj returns the list of values that were appended to the "big_xj" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedBigXj() ([]schema.ECDSAPub, bool) {
	if len(m.appendbig_xj) == 0 {
		return nil, false
	}
	return m.appendbig_xj, true
}

// ResetBigXj resets all changes to the "big_xj" field.
func (m *EcdsaLocalDataMutation) ResetBigXj() {
	m.big_xj = nil
	m.appendbig_xj = nil
}

// SetPaillierPks sets the "paillier_pks" field.
func (m *EcdsaLocalDataMutation) SetPaillierPks(s []string) {
	m.paillier_pks = &s
	m.appendpaillier_pks = nil
}

// PaillierPks returns the value of the "paillier_pks" field in the mutation.
func (m *EcdsaLocalDataMutation) PaillierPks() (r []string, exists bool) {
	v := m.paillier_pks
	if v == nil {
		return
	}
	return *v, true
}

// OldPaillierPks returns the old "paillier_pks" field's value of the EcdsaLocalData entity.
// If the EcdsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EcdsaLocalDataMutation) OldPaillierPks(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaillierPks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaillierPks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaillierPks: %w", err)
	}
	return oldValue.PaillierPks, nil
}

// AppendPaillierPks adds s to the "paillier_pks" field.
func (m *EcdsaLocalDataMutation) AppendPaillierPks(s []string) {
	m.appendpaillier_pks = append(m.appendpaillier_pks, s...)
}

// AppendedPaillierPks returns the list of values that were appended to the "paillier_pks" field in this mutation.
func (m *EcdsaLocalDataMutation) AppendedPaillierPks() ([]string, bool) {
	if len(m.appendpaillier_pks) == 0 {
		return nil, false
	}
	return m.appendpaillier_pks, true
}

// ResetPaillierPks resets all changes to the "paillier_pks" field.
func (m *EcdsaLocalDataMutation) ResetPaillierPks() {
	m.paillier_pks = nil
	m.appendpaillier_pks = nil
}

// SetVaultID sets the "vault" edge to the Vault entity by id.
func (m *EcdsaLocalDataMutation) SetVaultID(id int) {
	m.vault = &id
}

// ClearVault clears the "vault" edge to the Vault entity.
func (m *EcdsaLocalDataMutation) ClearVault() {
	m.clearedvault = true
}

// VaultCleared reports if the "vault" edge to the Vault entity was cleared.
func (m *EcdsaLocalDataMutation) VaultCleared() bool {
	return m.clearedvault
}

// VaultID returns the "vault" edge ID in the mutation.
func (m *EcdsaLocalDataMutation) VaultID() (id int, exists bool) {
	if m.vault != nil {
		return *m.vault, true
	}
	return
}

// VaultIDs returns the "vault" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VaultID instead. It exists only for internal usage by the builders.
func (m *EcdsaLocalDataMutation) VaultIDs() (ids []int) {
	if id := m.vault; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVault resets all changes to the "vault" edge.
func (m *EcdsaLocalDataMutation) ResetVault() {
	m.vault = nil
	m.clearedvault = false
}

// Where appends a list predicates to the EcdsaLocalDataMutation builder.
func (m *EcdsaLocalDataMutation) Where(ps ...predicate.EcdsaLocalData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EcdsaLocalDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EcdsaLocalDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EcdsaLocalData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EcdsaLocalDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EcdsaLocalDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EcdsaLocalData).
func (m *EcdsaLocalDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EcdsaLocalDataMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.n_tilde_i != nil {
		fields = append(fields, ecdsalocaldata.FieldNTildeI)
	}
	if m.h1i != nil {
		fields = append(fields, ecdsalocaldata.FieldH1i)
	}
	if m.h2i != nil {
		fields = append(fields, ecdsalocaldata.FieldH2i)
	}
	if m.alpha != nil {
		fields = append(fields, ecdsalocaldata.FieldAlpha)
	}
	if m.beta != nil {
		fields = append(fields, ecdsalocaldata.FieldBeta)
	}
	if m.p != nil {
		fields = append(fields, ecdsalocaldata.FieldP)
	}
	if m.q != nil {
		fields = append(fields, ecdsalocaldata.FieldQ)
	}
	if m.xi != nil {
		fields = append(fields, ecdsalocaldata.FieldXi)
	}
	if m.share_id != nil {
		fields = append(fields, ecdsalocaldata.FieldShareID)
	}
	if m.ks != nil {
		fields = append(fields, ecdsalocaldata.FieldKs)
	}
	if m.n_tilde_j != nil {
		fields = append(fields, ecdsalocaldata.FieldNTildeJ)
	}
	if m.h1j != nil {
		fields = append(fields, ecdsalocaldata.FieldH1j)
	}
	if m.h2j != nil {
		fields = append(fields, ecdsalocaldata.FieldH2j)
	}
	if m.big_xj != nil {
		fields = append(fields, ecdsalocaldata.FieldBigXj)
	}
	if m.paillier_pks != nil {
		fields = append(fields, ecdsalocaldata.FieldPaillierPks)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EcdsaLocalDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ecdsalocaldata.FieldNTildeI:
		return m.NTildeI()
	case ecdsalocaldata.FieldH1i:
		return m.H1i()
	case ecdsalocaldata.FieldH2i:
		return m.H2i()
	case ecdsalocaldata.FieldAlpha:
		return m.Alpha()
	case ecdsalocaldata.FieldBeta:
		return m.Beta()
	case ecdsalocaldata.FieldP:
		return m.P()
	case ecdsalocaldata.FieldQ:
		return m.Q()
	case ecdsalocaldata.FieldXi:
		return m.Xi()
	case ecdsalocaldata.FieldShareID:
		return m.ShareID()
	case ecdsalocaldata.FieldKs:
		return m.Ks()
	case ecdsalocaldata.FieldNTildeJ:
		return m.NTildeJ()
	case ecdsalocaldata.FieldH1j:
		return m.H1j()
	case ecdsalocaldata.FieldH2j:
		return m.H2j()
	case ecdsalocaldata.FieldBigXj:
		return m.BigXj()
	case ecdsalocaldata.FieldPaillierPks:
		return m.PaillierPks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EcdsaLocalDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ecdsalocaldata.FieldNTildeI:
		return m.OldNTildeI(ctx)
	case ecdsalocaldata.FieldH1i:
		return m.OldH1i(ctx)
	case ecdsalocaldata.FieldH2i:
		return m.OldH2i(ctx)
	case ecdsalocaldata.FieldAlpha:
		return m.OldAlpha(ctx)
	case ecdsalocaldata.FieldBeta:
		return m.OldBeta(ctx)
	case ecdsalocaldata.FieldP:
		return m.OldP(ctx)
	case ecdsalocaldata.FieldQ:
		return m.OldQ(ctx)
	case ecdsalocaldata.FieldXi:
		return m.OldXi(ctx)
	case ecdsalocaldata.FieldShareID:
		return m.OldShareID(ctx)
	case ecdsalocaldata.FieldKs:
		return m.OldKs(ctx)
	case ecdsalocaldata.FieldNTildeJ:
		return m.OldNTildeJ(ctx)
	case ecdsalocaldata.FieldH1j:
		return m.OldH1j(ctx)
	case ecdsalocaldata.FieldH2j:
		return m.OldH2j(ctx)
	case ecdsalocaldata.FieldBigXj:
		return m.OldBigXj(ctx)
	case ecdsalocaldata.FieldPaillierPks:
		return m.OldPaillierPks(ctx)
	}
	return nil, fmt.Errorf("unknown EcdsaLocalData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EcdsaLocalDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ecdsalocaldata.FieldNTildeI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNTildeI(v)
		return nil
	case ecdsalocaldata.FieldH1i:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH1i(v)
		return nil
	case ecdsalocaldata.FieldH2i:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH2i(v)
		return nil
	case ecdsalocaldata.FieldAlpha:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlpha(v)
		return nil
	case ecdsalocaldata.FieldBeta:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeta(v)
		return nil
	case ecdsalocaldata.FieldP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetP(v)
		return nil
	case ecdsalocaldata.FieldQ:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQ(v)
		return nil
	case ecdsalocaldata.FieldXi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXi(v)
		return nil
	case ecdsalocaldata.FieldShareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareID(v)
		return nil
	case ecdsalocaldata.FieldKs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKs(v)
		return nil
	case ecdsalocaldata.FieldNTildeJ:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNTildeJ(v)
		return nil
	case ecdsalocaldata.FieldH1j:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH1j(v)
		return nil
	case ecdsalocaldata.FieldH2j:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH2j(v)
		return nil
	case ecdsalocaldata.FieldBigXj:
		v, ok := value.([]schema.ECDSAPub)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigXj(v)
		return nil
	case ecdsalocaldata.FieldPaillierPks:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaillierPks(v)
		return nil
	}
	return fmt.Errorf("unknown EcdsaLocalData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EcdsaLocalDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EcdsaLocalDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EcdsaLocalDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EcdsaLocalData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EcdsaLocalDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EcdsaLocalDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EcdsaLocalDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EcdsaLocalData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EcdsaLocalDataMutation) ResetField(name string) error {
	switch name {
	case ecdsalocaldata.FieldNTildeI:
		m.ResetNTildeI()
		return nil
	case ecdsalocaldata.FieldH1i:
		m.ResetH1i()
		return nil
	case ecdsalocaldata.FieldH2i:
		m.ResetH2i()
		return nil
	case ecdsalocaldata.FieldAlpha:
		m.ResetAlpha()
		return nil
	case ecdsalocaldata.FieldBeta:
		m.ResetBeta()
		return nil
	case ecdsalocaldata.FieldP:
		m.ResetP()
		return nil
	case ecdsalocaldata.FieldQ:
		m.ResetQ()
		return nil
	case ecdsalocaldata.FieldXi:
		m.ResetXi()
		return nil
	case ecdsalocaldata.FieldShareID:
		m.ResetShareID()
		return nil
	case ecdsalocaldata.FieldKs:
		m.ResetKs()
		return nil
	case ecdsalocaldata.FieldNTildeJ:
		m.ResetNTildeJ()
		return nil
	case ecdsalocaldata.FieldH1j:
		m.ResetH1j()
		return nil
	case ecdsalocaldata.FieldH2j:
		m.ResetH2j()
		return nil
	case ecdsalocaldata.FieldBigXj:
		m.ResetBigXj()
		return nil
	case ecdsalocaldata.FieldPaillierPks:
		m.ResetPaillierPks()
		return nil
	}
	return fmt.Errorf("unknown EcdsaLocalData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EcdsaLocalDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vault != nil {
		edges = append(edges, ecdsalocaldata.EdgeVault)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EcdsaLocalDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ecdsalocaldata.EdgeVault:
		if id := m.vault; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EcdsaLocalDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EcdsaLocalDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EcdsaLocalDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvault {
		edges = append(edges, ecdsalocaldata.EdgeVault)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EcdsaLocalDataMutation) EdgeCleared(name string) bool {
	switch name {
	case ecdsalocaldata.EdgeVault:
		return m.clearedvault
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EcdsaLocalDataMutation) ClearEdge(name string) error {
	switch name {
	case ecdsalocaldata.EdgeVault:
		m.ClearVault()
		return nil
	}
	return fmt.Errorf("unknown EcdsaLocalData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EcdsaLocalDataMutation) ResetEdge(name string) error {
	switch name {
	case ecdsalocaldata.EdgeVault:
		m.ResetVault()
		return nil
	}
	return fmt.Errorf("unknown EcdsaLocalData edge %s", name)
}

// EddsaLocalDataMutation represents an operation that mutates the EddsaLocalData nodes in the graph.
type EddsaLocalDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	xi            *string
	share_id      *string
	ks            *string
	big_xj        *string
	eddsa_pub     *string
	clearedFields map[string]struct{}
	vault         *int
	clearedvault  bool
	done          bool
	oldValue      func(context.Context) (*EddsaLocalData, error)
	predicates    []predicate.EddsaLocalData
}

var _ ent.Mutation = (*EddsaLocalDataMutation)(nil)

// eddsalocaldataOption allows management of the mutation configuration using functional options.
type eddsalocaldataOption func(*EddsaLocalDataMutation)

// newEddsaLocalDataMutation creates new mutation for the EddsaLocalData entity.
func newEddsaLocalDataMutation(c config, op Op, opts ...eddsalocaldataOption) *EddsaLocalDataMutation {
	m := &EddsaLocalDataMutation{
		config:        c,
		op:            op,
		typ:           TypeEddsaLocalData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEddsaLocalDataID sets the ID field of the mutation.
func withEddsaLocalDataID(id int) eddsalocaldataOption {
	return func(m *EddsaLocalDataMutation) {
		var (
			err   error
			once  sync.Once
			value *EddsaLocalData
		)
		m.oldValue = func(ctx context.Context) (*EddsaLocalData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EddsaLocalData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEddsaLocalData sets the old EddsaLocalData of the mutation.
func withEddsaLocalData(node *EddsaLocalData) eddsalocaldataOption {
	return func(m *EddsaLocalDataMutation) {
		m.oldValue = func(context.Context) (*EddsaLocalData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EddsaLocalDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EddsaLocalDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EddsaLocalDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EddsaLocalDataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EddsaLocalData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetXi sets the "xi" field.
func (m *EddsaLocalDataMutation) SetXi(s string) {
	m.xi = &s
}

// Xi returns the value of the "xi" field in the mutation.
func (m *EddsaLocalDataMutation) Xi() (r string, exists bool) {
	v := m.xi
	if v == nil {
		return
	}
	return *v, true
}

// OldXi returns the old "xi" field's value of the EddsaLocalData entity.
// If the EddsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EddsaLocalDataMutation) OldXi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXi: %w", err)
	}
	return oldValue.Xi, nil
}

// ClearXi clears the value of the "xi" field.
func (m *EddsaLocalDataMutation) ClearXi() {
	m.xi = nil
	m.clearedFields[eddsalocaldata.FieldXi] = struct{}{}
}

// XiCleared returns if the "xi" field was cleared in this mutation.
func (m *EddsaLocalDataMutation) XiCleared() bool {
	_, ok := m.clearedFields[eddsalocaldata.FieldXi]
	return ok
}

// ResetXi resets all changes to the "xi" field.
func (m *EddsaLocalDataMutation) ResetXi() {
	m.xi = nil
	delete(m.clearedFields, eddsalocaldata.FieldXi)
}

// SetShareID sets the "share_id" field.
func (m *EddsaLocalDataMutation) SetShareID(s string) {
	m.share_id = &s
}

// ShareID returns the value of the "share_id" field in the mutation.
func (m *EddsaLocalDataMutation) ShareID() (r string, exists bool) {
	v := m.share_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShareID returns the old "share_id" field's value of the EddsaLocalData entity.
// If the EddsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EddsaLocalDataMutation) OldShareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareID: %w", err)
	}
	return oldValue.ShareID, nil
}

// ClearShareID clears the value of the "share_id" field.
func (m *EddsaLocalDataMutation) ClearShareID() {
	m.share_id = nil
	m.clearedFields[eddsalocaldata.FieldShareID] = struct{}{}
}

// ShareIDCleared returns if the "share_id" field was cleared in this mutation.
func (m *EddsaLocalDataMutation) ShareIDCleared() bool {
	_, ok := m.clearedFields[eddsalocaldata.FieldShareID]
	return ok
}

// ResetShareID resets all changes to the "share_id" field.
func (m *EddsaLocalDataMutation) ResetShareID() {
	m.share_id = nil
	delete(m.clearedFields, eddsalocaldata.FieldShareID)
}

// SetKs sets the "ks" field.
func (m *EddsaLocalDataMutation) SetKs(s string) {
	m.ks = &s
}

// Ks returns the value of the "ks" field in the mutation.
func (m *EddsaLocalDataMutation) Ks() (r string, exists bool) {
	v := m.ks
	if v == nil {
		return
	}
	return *v, true
}

// OldKs returns the old "ks" field's value of the EddsaLocalData entity.
// If the EddsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EddsaLocalDataMutation) OldKs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKs: %w", err)
	}
	return oldValue.Ks, nil
}

// ClearKs clears the value of the "ks" field.
func (m *EddsaLocalDataMutation) ClearKs() {
	m.ks = nil
	m.clearedFields[eddsalocaldata.FieldKs] = struct{}{}
}

// KsCleared returns if the "ks" field was cleared in this mutation.
func (m *EddsaLocalDataMutation) KsCleared() bool {
	_, ok := m.clearedFields[eddsalocaldata.FieldKs]
	return ok
}

// ResetKs resets all changes to the "ks" field.
func (m *EddsaLocalDataMutation) ResetKs() {
	m.ks = nil
	delete(m.clearedFields, eddsalocaldata.FieldKs)
}

// SetBigXj sets the "big_xj" field.
func (m *EddsaLocalDataMutation) SetBigXj(s string) {
	m.big_xj = &s
}

// BigXj returns the value of the "big_xj" field in the mutation.
func (m *EddsaLocalDataMutation) BigXj() (r string, exists bool) {
	v := m.big_xj
	if v == nil {
		return
	}
	return *v, true
}

// OldBigXj returns the old "big_xj" field's value of the EddsaLocalData entity.
// If the EddsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EddsaLocalDataMutation) OldBigXj(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBigXj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBigXj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBigXj: %w", err)
	}
	return oldValue.BigXj, nil
}

// ClearBigXj clears the value of the "big_xj" field.
func (m *EddsaLocalDataMutation) ClearBigXj() {
	m.big_xj = nil
	m.clearedFields[eddsalocaldata.FieldBigXj] = struct{}{}
}

// BigXjCleared returns if the "big_xj" field was cleared in this mutation.
func (m *EddsaLocalDataMutation) BigXjCleared() bool {
	_, ok := m.clearedFields[eddsalocaldata.FieldBigXj]
	return ok
}

// ResetBigXj resets all changes to the "big_xj" field.
func (m *EddsaLocalDataMutation) ResetBigXj() {
	m.big_xj = nil
	delete(m.clearedFields, eddsalocaldata.FieldBigXj)
}

// SetEddsaPub sets the "eddsa_pub" field.
func (m *EddsaLocalDataMutation) SetEddsaPub(s string) {
	m.eddsa_pub = &s
}

// EddsaPub returns the value of the "eddsa_pub" field in the mutation.
func (m *EddsaLocalDataMutation) EddsaPub() (r string, exists bool) {
	v := m.eddsa_pub
	if v == nil {
		return
	}
	return *v, true
}

// OldEddsaPub returns the old "eddsa_pub" field's value of the EddsaLocalData entity.
// If the EddsaLocalData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EddsaLocalDataMutation) OldEddsaPub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEddsaPub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEddsaPub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEddsaPub: %w", err)
	}
	return oldValue.EddsaPub, nil
}

// ClearEddsaPub clears the value of the "eddsa_pub" field.
func (m *EddsaLocalDataMutation) ClearEddsaPub() {
	m.eddsa_pub = nil
	m.clearedFields[eddsalocaldata.FieldEddsaPub] = struct{}{}
}

// EddsaPubCleared returns if the "eddsa_pub" field was cleared in this mutation.
func (m *EddsaLocalDataMutation) EddsaPubCleared() bool {
	_, ok := m.clearedFields[eddsalocaldata.FieldEddsaPub]
	return ok
}

// ResetEddsaPub resets all changes to the "eddsa_pub" field.
func (m *EddsaLocalDataMutation) ResetEddsaPub() {
	m.eddsa_pub = nil
	delete(m.clearedFields, eddsalocaldata.FieldEddsaPub)
}

// SetVaultID sets the "vault" edge to the Vault entity by id.
func (m *EddsaLocalDataMutation) SetVaultID(id int) {
	m.vault = &id
}

// ClearVault clears the "vault" edge to the Vault entity.
func (m *EddsaLocalDataMutation) ClearVault() {
	m.clearedvault = true
}

// VaultCleared reports if the "vault" edge to the Vault entity was cleared.
func (m *EddsaLocalDataMutation) VaultCleared() bool {
	return m.clearedvault
}

// VaultID returns the "vault" edge ID in the mutation.
func (m *EddsaLocalDataMutation) VaultID() (id int, exists bool) {
	if m.vault != nil {
		return *m.vault, true
	}
	return
}

// VaultIDs returns the "vault" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VaultID instead. It exists only for internal usage by the builders.
func (m *EddsaLocalDataMutation) VaultIDs() (ids []int) {
	if id := m.vault; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVault resets all changes to the "vault" edge.
func (m *EddsaLocalDataMutation) ResetVault() {
	m.vault = nil
	m.clearedvault = false
}

// Where appends a list predicates to the EddsaLocalDataMutation builder.
func (m *EddsaLocalDataMutation) Where(ps ...predicate.EddsaLocalData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EddsaLocalDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EddsaLocalDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EddsaLocalData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EddsaLocalDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EddsaLocalDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EddsaLocalData).
func (m *EddsaLocalDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EddsaLocalDataMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.xi != nil {
		fields = append(fields, eddsalocaldata.FieldXi)
	}
	if m.share_id != nil {
		fields = append(fields, eddsalocaldata.FieldShareID)
	}
	if m.ks != nil {
		fields = append(fields, eddsalocaldata.FieldKs)
	}
	if m.big_xj != nil {
		fields = append(fields, eddsalocaldata.FieldBigXj)
	}
	if m.eddsa_pub != nil {
		fields = append(fields, eddsalocaldata.FieldEddsaPub)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EddsaLocalDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eddsalocaldata.FieldXi:
		return m.Xi()
	case eddsalocaldata.FieldShareID:
		return m.ShareID()
	case eddsalocaldata.FieldKs:
		return m.Ks()
	case eddsalocaldata.FieldBigXj:
		return m.BigXj()
	case eddsalocaldata.FieldEddsaPub:
		return m.EddsaPub()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EddsaLocalDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eddsalocaldata.FieldXi:
		return m.OldXi(ctx)
	case eddsalocaldata.FieldShareID:
		return m.OldShareID(ctx)
	case eddsalocaldata.FieldKs:
		return m.OldKs(ctx)
	case eddsalocaldata.FieldBigXj:
		return m.OldBigXj(ctx)
	case eddsalocaldata.FieldEddsaPub:
		return m.OldEddsaPub(ctx)
	}
	return nil, fmt.Errorf("unknown EddsaLocalData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EddsaLocalDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eddsalocaldata.FieldXi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXi(v)
		return nil
	case eddsalocaldata.FieldShareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareID(v)
		return nil
	case eddsalocaldata.FieldKs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKs(v)
		return nil
	case eddsalocaldata.FieldBigXj:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBigXj(v)
		return nil
	case eddsalocaldata.FieldEddsaPub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEddsaPub(v)
		return nil
	}
	return fmt.Errorf("unknown EddsaLocalData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EddsaLocalDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EddsaLocalDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EddsaLocalDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EddsaLocalData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EddsaLocalDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eddsalocaldata.FieldXi) {
		fields = append(fields, eddsalocaldata.FieldXi)
	}
	if m.FieldCleared(eddsalocaldata.FieldShareID) {
		fields = append(fields, eddsalocaldata.FieldShareID)
	}
	if m.FieldCleared(eddsalocaldata.FieldKs) {
		fields = append(fields, eddsalocaldata.FieldKs)
	}
	if m.FieldCleared(eddsalocaldata.FieldBigXj) {
		fields = append(fields, eddsalocaldata.FieldBigXj)
	}
	if m.FieldCleared(eddsalocaldata.FieldEddsaPub) {
		fields = append(fields, eddsalocaldata.FieldEddsaPub)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EddsaLocalDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EddsaLocalDataMutation) ClearField(name string) error {
	switch name {
	case eddsalocaldata.FieldXi:
		m.ClearXi()
		return nil
	case eddsalocaldata.FieldShareID:
		m.ClearShareID()
		return nil
	case eddsalocaldata.FieldKs:
		m.ClearKs()
		return nil
	case eddsalocaldata.FieldBigXj:
		m.ClearBigXj()
		return nil
	case eddsalocaldata.FieldEddsaPub:
		m.ClearEddsaPub()
		return nil
	}
	return fmt.Errorf("unknown EddsaLocalData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EddsaLocalDataMutation) ResetField(name string) error {
	switch name {
	case eddsalocaldata.FieldXi:
		m.ResetXi()
		return nil
	case eddsalocaldata.FieldShareID:
		m.ResetShareID()
		return nil
	case eddsalocaldata.FieldKs:
		m.ResetKs()
		return nil
	case eddsalocaldata.FieldBigXj:
		m.ResetBigXj()
		return nil
	case eddsalocaldata.FieldEddsaPub:
		m.ResetEddsaPub()
		return nil
	}
	return fmt.Errorf("unknown EddsaLocalData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EddsaLocalDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vault != nil {
		edges = append(edges, eddsalocaldata.EdgeVault)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EddsaLocalDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eddsalocaldata.EdgeVault:
		if id := m.vault; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EddsaLocalDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EddsaLocalDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EddsaLocalDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvault {
		edges = append(edges, eddsalocaldata.EdgeVault)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EddsaLocalDataMutation) EdgeCleared(name string) bool {
	switch name {
	case eddsalocaldata.EdgeVault:
		return m.clearedvault
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EddsaLocalDataMutation) ClearEdge(name string) error {
	switch name {
	case eddsalocaldata.EdgeVault:
		m.ClearVault()
		return nil
	}
	return fmt.Errorf("unknown EddsaLocalData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EddsaLocalDataMutation) ResetEdge(name string) error {
	switch name {
	case eddsalocaldata.EdgeVault:
		m.ResetVault()
		return nil
	}
	return fmt.Errorf("unknown EddsaLocalData edge %s", name)
}

// PaillierSKMutation represents an operation that mutates the PaillierSK nodes in the graph.
type PaillierSKMutation struct {
	config
	op            Op
	typ           string
	id            *int
	n             *string
	lambda_n      *string
	phi_n         *string
	p             *string
	q             *string
	clearedFields map[string]struct{}
	vault         *int
	clearedvault  bool
	done          bool
	oldValue      func(context.Context) (*PaillierSK, error)
	predicates    []predicate.PaillierSK
}

var _ ent.Mutation = (*PaillierSKMutation)(nil)

// paillierskOption allows management of the mutation configuration using functional options.
type paillierskOption func(*PaillierSKMutation)

// newPaillierSKMutation creates new mutation for the PaillierSK entity.
func newPaillierSKMutation(c config, op Op, opts ...paillierskOption) *PaillierSKMutation {
	m := &PaillierSKMutation{
		config:        c,
		op:            op,
		typ:           TypePaillierSK,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaillierSKID sets the ID field of the mutation.
func withPaillierSKID(id int) paillierskOption {
	return func(m *PaillierSKMutation) {
		var (
			err   error
			once  sync.Once
			value *PaillierSK
		)
		m.oldValue = func(ctx context.Context) (*PaillierSK, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaillierSK.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaillierSK sets the old PaillierSK of the mutation.
func withPaillierSK(node *PaillierSK) paillierskOption {
	return func(m *PaillierSKMutation) {
		m.oldValue = func(context.Context) (*PaillierSK, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaillierSKMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaillierSKMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaillierSKMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaillierSKMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaillierSK.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetN sets the "n" field.
func (m *PaillierSKMutation) SetN(s string) {
	m.n = &s
}

// N returns the value of the "n" field in the mutation.
func (m *PaillierSKMutation) N() (r string, exists bool) {
	v := m.n
	if v == nil {
		return
	}
	return *v, true
}

// OldN returns the old "n" field's value of the PaillierSK entity.
// If the PaillierSK object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaillierSKMutation) OldN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldN: %w", err)
	}
	return oldValue.N, nil
}

// ResetN resets all changes to the "n" field.
func (m *PaillierSKMutation) ResetN() {
	m.n = nil
}

// SetLambdaN sets the "lambda_n" field.
func (m *PaillierSKMutation) SetLambdaN(s string) {
	m.lambda_n = &s
}

// LambdaN returns the value of the "lambda_n" field in the mutation.
func (m *PaillierSKMutation) LambdaN() (r string, exists bool) {
	v := m.lambda_n
	if v == nil {
		return
	}
	return *v, true
}

// OldLambdaN returns the old "lambda_n" field's value of the PaillierSK entity.
// If the PaillierSK object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaillierSKMutation) OldLambdaN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLambdaN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLambdaN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLambdaN: %w", err)
	}
	return oldValue.LambdaN, nil
}

// ResetLambdaN resets all changes to the "lambda_n" field.
func (m *PaillierSKMutation) ResetLambdaN() {
	m.lambda_n = nil
}

// SetPhiN sets the "phi_n" field.
func (m *PaillierSKMutation) SetPhiN(s string) {
	m.phi_n = &s
}

// PhiN returns the value of the "phi_n" field in the mutation.
func (m *PaillierSKMutation) PhiN() (r string, exists bool) {
	v := m.phi_n
	if v == nil {
		return
	}
	return *v, true
}

// OldPhiN returns the old "phi_n" field's value of the PaillierSK entity.
// If the PaillierSK object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaillierSKMutation) OldPhiN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhiN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhiN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhiN: %w", err)
	}
	return oldValue.PhiN, nil
}

// ResetPhiN resets all changes to the "phi_n" field.
func (m *PaillierSKMutation) ResetPhiN() {
	m.phi_n = nil
}

// SetP sets the "p" field.
func (m *PaillierSKMutation) SetP(s string) {
	m.p = &s
}

// P returns the value of the "p" field in the mutation.
func (m *PaillierSKMutation) P() (r string, exists bool) {
	v := m.p
	if v == nil {
		return
	}
	return *v, true
}

// OldP returns the old "p" field's value of the PaillierSK entity.
// If the PaillierSK object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaillierSKMutation) OldP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldP: %w", err)
	}
	return oldValue.P, nil
}

// ResetP resets all changes to the "p" field.
func (m *PaillierSKMutation) ResetP() {
	m.p = nil
}

// SetQ sets the "q" field.
func (m *PaillierSKMutation) SetQ(s string) {
	m.q = &s
}

// Q returns the value of the "q" field in the mutation.
func (m *PaillierSKMutation) Q() (r string, exists bool) {
	v := m.q
	if v == nil {
		return
	}
	return *v, true
}

// OldQ returns the old "q" field's value of the PaillierSK entity.
// If the PaillierSK object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaillierSKMutation) OldQ(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQ is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQ requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQ: %w", err)
	}
	return oldValue.Q, nil
}

// ResetQ resets all changes to the "q" field.
func (m *PaillierSKMutation) ResetQ() {
	m.q = nil
}

// SetVaultID sets the "vault" edge to the Vault entity by id.
func (m *PaillierSKMutation) SetVaultID(id int) {
	m.vault = &id
}

// ClearVault clears the "vault" edge to the Vault entity.
func (m *PaillierSKMutation) ClearVault() {
	m.clearedvault = true
}

// VaultCleared reports if the "vault" edge to the Vault entity was cleared.
func (m *PaillierSKMutation) VaultCleared() bool {
	return m.clearedvault
}

// VaultID returns the "vault" edge ID in the mutation.
func (m *PaillierSKMutation) VaultID() (id int, exists bool) {
	if m.vault != nil {
		return *m.vault, true
	}
	return
}

// VaultIDs returns the "vault" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VaultID instead. It exists only for internal usage by the builders.
func (m *PaillierSKMutation) VaultIDs() (ids []int) {
	if id := m.vault; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVault resets all changes to the "vault" edge.
func (m *PaillierSKMutation) ResetVault() {
	m.vault = nil
	m.clearedvault = false
}

// Where appends a list predicates to the PaillierSKMutation builder.
func (m *PaillierSKMutation) Where(ps ...predicate.PaillierSK) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaillierSKMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaillierSKMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaillierSK, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaillierSKMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaillierSKMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaillierSK).
func (m *PaillierSKMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaillierSKMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.n != nil {
		fields = append(fields, pailliersk.FieldN)
	}
	if m.lambda_n != nil {
		fields = append(fields, pailliersk.FieldLambdaN)
	}
	if m.phi_n != nil {
		fields = append(fields, pailliersk.FieldPhiN)
	}
	if m.p != nil {
		fields = append(fields, pailliersk.FieldP)
	}
	if m.q != nil {
		fields = append(fields, pailliersk.FieldQ)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaillierSKMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pailliersk.FieldN:
		return m.N()
	case pailliersk.FieldLambdaN:
		return m.LambdaN()
	case pailliersk.FieldPhiN:
		return m.PhiN()
	case pailliersk.FieldP:
		return m.P()
	case pailliersk.FieldQ:
		return m.Q()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaillierSKMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pailliersk.FieldN:
		return m.OldN(ctx)
	case pailliersk.FieldLambdaN:
		return m.OldLambdaN(ctx)
	case pailliersk.FieldPhiN:
		return m.OldPhiN(ctx)
	case pailliersk.FieldP:
		return m.OldP(ctx)
	case pailliersk.FieldQ:
		return m.OldQ(ctx)
	}
	return nil, fmt.Errorf("unknown PaillierSK field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaillierSKMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pailliersk.FieldN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetN(v)
		return nil
	case pailliersk.FieldLambdaN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLambdaN(v)
		return nil
	case pailliersk.FieldPhiN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhiN(v)
		return nil
	case pailliersk.FieldP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetP(v)
		return nil
	case pailliersk.FieldQ:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQ(v)
		return nil
	}
	return fmt.Errorf("unknown PaillierSK field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaillierSKMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaillierSKMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaillierSKMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PaillierSK numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaillierSKMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaillierSKMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaillierSKMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PaillierSK nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaillierSKMutation) ResetField(name string) error {
	switch name {
	case pailliersk.FieldN:
		m.ResetN()
		return nil
	case pailliersk.FieldLambdaN:
		m.ResetLambdaN()
		return nil
	case pailliersk.FieldPhiN:
		m.ResetPhiN()
		return nil
	case pailliersk.FieldP:
		m.ResetP()
		return nil
	case pailliersk.FieldQ:
		m.ResetQ()
		return nil
	}
	return fmt.Errorf("unknown PaillierSK field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaillierSKMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vault != nil {
		edges = append(edges, pailliersk.EdgeVault)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaillierSKMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pailliersk.EdgeVault:
		if id := m.vault; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaillierSKMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaillierSKMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaillierSKMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvault {
		edges = append(edges, pailliersk.EdgeVault)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaillierSKMutation) EdgeCleared(name string) bool {
	switch name {
	case pailliersk.EdgeVault:
		return m.clearedvault
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaillierSKMutation) ClearEdge(name string) error {
	switch name {
	case pailliersk.EdgeVault:
		m.ClearVault()
		return nil
	}
	return fmt.Errorf("unknown PaillierSK unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaillierSKMutation) ResetEdge(name string) error {
	switch name {
	case pailliersk.EdgeVault:
		m.ResetVault()
		return nil
	}
	return fmt.Errorf("unknown PaillierSK edge %s", name)
}

// VaultMutation represents an operation that mutates the Vault nodes in the graph.
type VaultMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	name                        *string
	pub_key                     *string
	keygen_committee_keys       *[]string
	appendkeygen_committee_keys []string
	local_party_key             *string
	chain_code_hex              *string
	reshare_prefix              *string
	clearedFields               map[string]struct{}
	paillier_sk                 *int
	clearedpaillier_sk          bool
	ecdsa_local_data            *int
	clearedecdsa_local_data     bool
	eddsa_local_data            *int
	clearededdsa_local_data     bool
	done                        bool
	oldValue                    func(context.Context) (*Vault, error)
	predicates                  []predicate.Vault
}

var _ ent.Mutation = (*VaultMutation)(nil)

// vaultOption allows management of the mutation configuration using functional options.
type vaultOption func(*VaultMutation)

// newVaultMutation creates new mutation for the Vault entity.
func newVaultMutation(c config, op Op, opts ...vaultOption) *VaultMutation {
	m := &VaultMutation{
		config:        c,
		op:            op,
		typ:           TypeVault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaultID sets the ID field of the mutation.
func withVaultID(id int) vaultOption {
	return func(m *VaultMutation) {
		var (
			err   error
			once  sync.Once
			value *Vault
		)
		m.oldValue = func(ctx context.Context) (*Vault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVault sets the old Vault of the mutation.
func withVault(node *Vault) vaultOption {
	return func(m *VaultMutation) {
		m.oldValue = func(context.Context) (*Vault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VaultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VaultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VaultMutation) ResetName() {
	m.name = nil
}

// SetPubKey sets the "pub_key" field.
func (m *VaultMutation) SetPubKey(s string) {
	m.pub_key = &s
}

// PubKey returns the value of the "pub_key" field in the mutation.
func (m *VaultMutation) PubKey() (r string, exists bool) {
	v := m.pub_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPubKey returns the old "pub_key" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldPubKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPubKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPubKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPubKey: %w", err)
	}
	return oldValue.PubKey, nil
}

// ResetPubKey resets all changes to the "pub_key" field.
func (m *VaultMutation) ResetPubKey() {
	m.pub_key = nil
}

// SetKeygenCommitteeKeys sets the "keygen_committee_keys" field.
func (m *VaultMutation) SetKeygenCommitteeKeys(s []string) {
	m.keygen_committee_keys = &s
	m.appendkeygen_committee_keys = nil
}

// KeygenCommitteeKeys returns the value of the "keygen_committee_keys" field in the mutation.
func (m *VaultMutation) KeygenCommitteeKeys() (r []string, exists bool) {
	v := m.keygen_committee_keys
	if v == nil {
		return
	}
	return *v, true
}

// OldKeygenCommitteeKeys returns the old "keygen_committee_keys" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldKeygenCommitteeKeys(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeygenCommitteeKeys is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeygenCommitteeKeys requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeygenCommitteeKeys: %w", err)
	}
	return oldValue.KeygenCommitteeKeys, nil
}

// AppendKeygenCommitteeKeys adds s to the "keygen_committee_keys" field.
func (m *VaultMutation) AppendKeygenCommitteeKeys(s []string) {
	m.appendkeygen_committee_keys = append(m.appendkeygen_committee_keys, s...)
}

// AppendedKeygenCommitteeKeys returns the list of values that were appended to the "keygen_committee_keys" field in this mutation.
func (m *VaultMutation) AppendedKeygenCommitteeKeys() ([]string, bool) {
	if len(m.appendkeygen_committee_keys) == 0 {
		return nil, false
	}
	return m.appendkeygen_committee_keys, true
}

// ResetKeygenCommitteeKeys resets all changes to the "keygen_committee_keys" field.
func (m *VaultMutation) ResetKeygenCommitteeKeys() {
	m.keygen_committee_keys = nil
	m.appendkeygen_committee_keys = nil
}

// SetLocalPartyKey sets the "local_party_key" field.
func (m *VaultMutation) SetLocalPartyKey(s string) {
	m.local_party_key = &s
}

// LocalPartyKey returns the value of the "local_party_key" field in the mutation.
func (m *VaultMutation) LocalPartyKey() (r string, exists bool) {
	v := m.local_party_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalPartyKey returns the old "local_party_key" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldLocalPartyKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalPartyKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalPartyKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalPartyKey: %w", err)
	}
	return oldValue.LocalPartyKey, nil
}

// ResetLocalPartyKey resets all changes to the "local_party_key" field.
func (m *VaultMutation) ResetLocalPartyKey() {
	m.local_party_key = nil
}

// SetChainCodeHex sets the "chain_code_hex" field.
func (m *VaultMutation) SetChainCodeHex(s string) {
	m.chain_code_hex = &s
}

// ChainCodeHex returns the value of the "chain_code_hex" field in the mutation.
func (m *VaultMutation) ChainCodeHex() (r string, exists bool) {
	v := m.chain_code_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldChainCodeHex returns the old "chain_code_hex" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldChainCodeHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainCodeHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainCodeHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainCodeHex: %w", err)
	}
	return oldValue.ChainCodeHex, nil
}

// ResetChainCodeHex resets all changes to the "chain_code_hex" field.
func (m *VaultMutation) ResetChainCodeHex() {
	m.chain_code_hex = nil
}

// SetResharePrefix sets the "reshare_prefix" field.
func (m *VaultMutation) SetResharePrefix(s string) {
	m.reshare_prefix = &s
}

// ResharePrefix returns the value of the "reshare_prefix" field in the mutation.
func (m *VaultMutation) ResharePrefix() (r string, exists bool) {
	v := m.reshare_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldResharePrefix returns the old "reshare_prefix" field's value of the Vault entity.
// If the Vault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaultMutation) OldResharePrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResharePrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResharePrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResharePrefix: %w", err)
	}
	return oldValue.ResharePrefix, nil
}

// ClearResharePrefix clears the value of the "reshare_prefix" field.
func (m *VaultMutation) ClearResharePrefix() {
	m.reshare_prefix = nil
	m.clearedFields[vault.FieldResharePrefix] = struct{}{}
}

// ResharePrefixCleared returns if the "reshare_prefix" field was cleared in this mutation.
func (m *VaultMutation) ResharePrefixCleared() bool {
	_, ok := m.clearedFields[vault.FieldResharePrefix]
	return ok
}

// ResetResharePrefix resets all changes to the "reshare_prefix" field.
func (m *VaultMutation) ResetResharePrefix() {
	m.reshare_prefix = nil
	delete(m.clearedFields, vault.FieldResharePrefix)
}

// SetPaillierSkID sets the "paillier_sk" edge to the PaillierSK entity by id.
func (m *VaultMutation) SetPaillierSkID(id int) {
	m.paillier_sk = &id
}

// ClearPaillierSk clears the "paillier_sk" edge to the PaillierSK entity.
func (m *VaultMutation) ClearPaillierSk() {
	m.clearedpaillier_sk = true
}

// PaillierSkCleared reports if the "paillier_sk" edge to the PaillierSK entity was cleared.
func (m *VaultMutation) PaillierSkCleared() bool {
	return m.clearedpaillier_sk
}

// PaillierSkID returns the "paillier_sk" edge ID in the mutation.
func (m *VaultMutation) PaillierSkID() (id int, exists bool) {
	if m.paillier_sk != nil {
		return *m.paillier_sk, true
	}
	return
}

// PaillierSkIDs returns the "paillier_sk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaillierSkID instead. It exists only for internal usage by the builders.
func (m *VaultMutation) PaillierSkIDs() (ids []int) {
	if id := m.paillier_sk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPaillierSk resets all changes to the "paillier_sk" edge.
func (m *VaultMutation) ResetPaillierSk() {
	m.paillier_sk = nil
	m.clearedpaillier_sk = false
}

// SetEcdsaLocalDataID sets the "ecdsa_local_data" edge to the EcdsaLocalData entity by id.
func (m *VaultMutation) SetEcdsaLocalDataID(id int) {
	m.ecdsa_local_data = &id
}

// ClearEcdsaLocalData clears the "ecdsa_local_data" edge to the EcdsaLocalData entity.
func (m *VaultMutation) ClearEcdsaLocalData() {
	m.clearedecdsa_local_data = true
}

// EcdsaLocalDataCleared reports if the "ecdsa_local_data" edge to the EcdsaLocalData entity was cleared.
func (m *VaultMutation) EcdsaLocalDataCleared() bool {
	return m.clearedecdsa_local_data
}

// EcdsaLocalDataID returns the "ecdsa_local_data" edge ID in the mutation.
func (m *VaultMutation) EcdsaLocalDataID() (id int, exists bool) {
	if m.ecdsa_local_data != nil {
		return *m.ecdsa_local_data, true
	}
	return
}

// EcdsaLocalDataIDs returns the "ecdsa_local_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EcdsaLocalDataID instead. It exists only for internal usage by the builders.
func (m *VaultMutation) EcdsaLocalDataIDs() (ids []int) {
	if id := m.ecdsa_local_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEcdsaLocalData resets all changes to the "ecdsa_local_data" edge.
func (m *VaultMutation) ResetEcdsaLocalData() {
	m.ecdsa_local_data = nil
	m.clearedecdsa_local_data = false
}

// SetEddsaLocalDataID sets the "eddsa_local_data" edge to the EddsaLocalData entity by id.
func (m *VaultMutation) SetEddsaLocalDataID(id int) {
	m.eddsa_local_data = &id
}

// ClearEddsaLocalData clears the "eddsa_local_data" edge to the EddsaLocalData entity.
func (m *VaultMutation) ClearEddsaLocalData() {
	m.clearededdsa_local_data = true
}

// EddsaLocalDataCleared reports if the "eddsa_local_data" edge to the EddsaLocalData entity was cleared.
func (m *VaultMutation) EddsaLocalDataCleared() bool {
	return m.clearededdsa_local_data
}

// EddsaLocalDataID returns the "eddsa_local_data" edge ID in the mutation.
func (m *VaultMutation) EddsaLocalDataID() (id int, exists bool) {
	if m.eddsa_local_data != nil {
		return *m.eddsa_local_data, true
	}
	return
}

// EddsaLocalDataIDs returns the "eddsa_local_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EddsaLocalDataID instead. It exists only for internal usage by the builders.
func (m *VaultMutation) EddsaLocalDataIDs() (ids []int) {
	if id := m.eddsa_local_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEddsaLocalData resets all changes to the "eddsa_local_data" edge.
func (m *VaultMutation) ResetEddsaLocalData() {
	m.eddsa_local_data = nil
	m.clearededdsa_local_data = false
}

// Where appends a list predicates to the VaultMutation builder.
func (m *VaultMutation) Where(ps ...predicate.Vault) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VaultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VaultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vault, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VaultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VaultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vault).
func (m *VaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaultMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, vault.FieldName)
	}
	if m.pub_key != nil {
		fields = append(fields, vault.FieldPubKey)
	}
	if m.keygen_committee_keys != nil {
		fields = append(fields, vault.FieldKeygenCommitteeKeys)
	}
	if m.local_party_key != nil {
		fields = append(fields, vault.FieldLocalPartyKey)
	}
	if m.chain_code_hex != nil {
		fields = append(fields, vault.FieldChainCodeHex)
	}
	if m.reshare_prefix != nil {
		fields = append(fields, vault.FieldResharePrefix)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vault.FieldName:
		return m.Name()
	case vault.FieldPubKey:
		return m.PubKey()
	case vault.FieldKeygenCommitteeKeys:
		return m.KeygenCommitteeKeys()
	case vault.FieldLocalPartyKey:
		return m.LocalPartyKey()
	case vault.FieldChainCodeHex:
		return m.ChainCodeHex()
	case vault.FieldResharePrefix:
		return m.ResharePrefix()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vault.FieldName:
		return m.OldName(ctx)
	case vault.FieldPubKey:
		return m.OldPubKey(ctx)
	case vault.FieldKeygenCommitteeKeys:
		return m.OldKeygenCommitteeKeys(ctx)
	case vault.FieldLocalPartyKey:
		return m.OldLocalPartyKey(ctx)
	case vault.FieldChainCodeHex:
		return m.OldChainCodeHex(ctx)
	case vault.FieldResharePrefix:
		return m.OldResharePrefix(ctx)
	}
	return nil, fmt.Errorf("unknown Vault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vault.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case vault.FieldPubKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPubKey(v)
		return nil
	case vault.FieldKeygenCommitteeKeys:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeygenCommitteeKeys(v)
		return nil
	case vault.FieldLocalPartyKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalPartyKey(v)
		return nil
	case vault.FieldChainCodeHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainCodeHex(v)
		return nil
	case vault.FieldResharePrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResharePrefix(v)
		return nil
	}
	return fmt.Errorf("unknown Vault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vault.FieldResharePrefix) {
		fields = append(fields, vault.FieldResharePrefix)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaultMutation) ClearField(name string) error {
	switch name {
	case vault.FieldResharePrefix:
		m.ClearResharePrefix()
		return nil
	}
	return fmt.Errorf("unknown Vault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaultMutation) ResetField(name string) error {
	switch name {
	case vault.FieldName:
		m.ResetName()
		return nil
	case vault.FieldPubKey:
		m.ResetPubKey()
		return nil
	case vault.FieldKeygenCommitteeKeys:
		m.ResetKeygenCommitteeKeys()
		return nil
	case vault.FieldLocalPartyKey:
		m.ResetLocalPartyKey()
		return nil
	case vault.FieldChainCodeHex:
		m.ResetChainCodeHex()
		return nil
	case vault.FieldResharePrefix:
		m.ResetResharePrefix()
		return nil
	}
	return fmt.Errorf("unknown Vault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.paillier_sk != nil {
		edges = append(edges, vault.EdgePaillierSk)
	}
	if m.ecdsa_local_data != nil {
		edges = append(edges, vault.EdgeEcdsaLocalData)
	}
	if m.eddsa_local_data != nil {
		edges = append(edges, vault.EdgeEddsaLocalData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vault.EdgePaillierSk:
		if id := m.paillier_sk; id != nil {
			return []ent.Value{*id}
		}
	case vault.EdgeEcdsaLocalData:
		if id := m.ecdsa_local_data; id != nil {
			return []ent.Value{*id}
		}
	case vault.EdgeEddsaLocalData:
		if id := m.eddsa_local_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpaillier_sk {
		edges = append(edges, vault.EdgePaillierSk)
	}
	if m.clearedecdsa_local_data {
		edges = append(edges, vault.EdgeEcdsaLocalData)
	}
	if m.clearededdsa_local_data {
		edges = append(edges, vault.EdgeEddsaLocalData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaultMutation) EdgeCleared(name string) bool {
	switch name {
	case vault.EdgePaillierSk:
		return m.clearedpaillier_sk
	case vault.EdgeEcdsaLocalData:
		return m.clearedecdsa_local_data
	case vault.EdgeEddsaLocalData:
		return m.clearededdsa_local_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaultMutation) ClearEdge(name string) error {
	switch name {
	case vault.EdgePaillierSk:
		m.ClearPaillierSk()
		return nil
	case vault.EdgeEcdsaLocalData:
		m.ClearEcdsaLocalData()
		return nil
	case vault.EdgeEddsaLocalData:
		m.ClearEddsaLocalData()
		return nil
	}
	return fmt.Errorf("unknown Vault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaultMutation) ResetEdge(name string) error {
	switch name {
	case vault.EdgePaillierSk:
		m.ResetPaillierSk()
		return nil
	case vault.EdgeEcdsaLocalData:
		m.ResetEcdsaLocalData()
		return nil
	case vault.EdgeEddsaLocalData:
		m.ResetEddsaLocalData()
		return nil
	}
	return fmt.Errorf("unknown Vault edge %s", name)
}
